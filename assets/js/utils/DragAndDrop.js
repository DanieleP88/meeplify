/**
 * Drag and Drop Utility for reordering elements
 */
export class DragAndDrop {
    constructor(options = {}) {
        this.container = options.container;
        this.draggableSelector = options.draggableSelector || '[draggable="true"]';
        this.onReorder = options.onReorder || (() => {});
        this.onDragStart = options.onDragStart || (() => {});
        this.onDragEnd = options.onDragEnd || (() => {});
        
        this.draggedElement = null;
        this.placeholder = null;
        this.isDragging = false;
        
        if (this.container) {\n            this.init();\n        }\n    }\n    \n    /**\n     * Initialize drag and drop\n     */\n    init() {\n        this.container.addEventListener('dragstart', this.handleDragStart.bind(this));\n        this.container.addEventListener('dragend', this.handleDragEnd.bind(this));\n        this.container.addEventListener('dragover', this.handleDragOver.bind(this));\n        this.container.addEventListener('drop', this.handleDrop.bind(this));\n        this.container.addEventListener('dragenter', this.handleDragEnter.bind(this));\n        this.container.addEventListener('dragleave', this.handleDragLeave.bind(this));\n    }\n    \n    /**\n     * Enable drag and drop for elements\n     */\n    enable(elements) {\n        elements.forEach(element => {\n            element.setAttribute('draggable', 'true');\n            element.classList.add('draggable');\n        });\n    }\n    \n    /**\n     * Disable drag and drop for elements\n     */\n    disable(elements) {\n        elements.forEach(element => {\n            element.setAttribute('draggable', 'false');\n            element.classList.remove('draggable');\n        });\n    }\n    \n    /**\n     * Handle drag start\n     */\n    handleDragStart(e) {\n        if (!e.target.matches(this.draggableSelector)) return;\n        \n        this.draggedElement = e.target;\n        this.isDragging = true;\n        \n        // Create placeholder\n        this.placeholder = document.createElement('div');\n        this.placeholder.className = 'drag-placeholder';\n        this.placeholder.style.height = `${this.draggedElement.offsetHeight}px`;\n        \n        // Add visual feedback\n        this.draggedElement.classList.add('dragging');\n        \n        // Set drag data\n        e.dataTransfer.effectAllowed = 'move';\n        e.dataTransfer.setData('text/html', this.draggedElement.outerHTML);\n        \n        this.onDragStart(this.draggedElement);\n        \n        // Delay to prevent immediate style application\n        requestAnimationFrame(() => {\n            if (this.draggedElement) {\n                this.draggedElement.style.opacity = '0.5';\n            }\n        });\n    }\n    \n    /**\n     * Handle drag end\n     */\n    handleDragEnd(e) {\n        if (!this.isDragging) return;\n        \n        this.isDragging = false;\n        \n        // Clean up\n        if (this.draggedElement) {\n            this.draggedElement.classList.remove('dragging');\n            this.draggedElement.style.opacity = '';\n        }\n        \n        if (this.placeholder && this.placeholder.parentNode) {\n            this.placeholder.parentNode.removeChild(this.placeholder);\n        }\n        \n        // Remove drag over classes\n        this.container.querySelectorAll('.drag-over').forEach(el => {\n            el.classList.remove('drag-over');\n        });\n        \n        this.onDragEnd(this.draggedElement);\n        \n        this.draggedElement = null;\n        this.placeholder = null;\n    }\n    \n    /**\n     * Handle drag over\n     */\n    handleDragOver(e) {\n        if (!this.isDragging) return;\n        \n        e.preventDefault();\n        e.dataTransfer.dropEffect = 'move';\n        \n        const target = this.findDropTarget(e.target);\n        if (!target || target === this.draggedElement) return;\n        \n        const rect = target.getBoundingClientRect();\n        const midpoint = rect.top + rect.height / 2;\n        \n        if (e.clientY < midpoint) {\n            // Insert before\n            target.parentNode.insertBefore(this.placeholder, target);\n        } else {\n            // Insert after\n            target.parentNode.insertBefore(this.placeholder, target.nextSibling);\n        }\n    }\n    \n    /**\n     * Handle drag enter\n     */\n    handleDragEnter(e) {\n        if (!this.isDragging) return;\n        \n        const target = this.findDropTarget(e.target);\n        if (target && target !== this.draggedElement) {\n            target.classList.add('drag-over');\n        }\n    }\n    \n    /**\n     * Handle drag leave\n     */\n    handleDragLeave(e) {\n        if (!this.isDragging) return;\n        \n        const target = this.findDropTarget(e.target);\n        if (target) {\n            target.classList.remove('drag-over');\n        }\n    }\n    \n    /**\n     * Handle drop\n     */\n    handleDrop(e) {\n        if (!this.isDragging) return;\n        \n        e.preventDefault();\n        \n        const target = this.findDropTarget(e.target);\n        if (!target || target === this.draggedElement) return;\n        \n        // Determine new position\n        const rect = target.getBoundingClientRect();\n        const midpoint = rect.top + rect.height / 2;\n        const insertBefore = e.clientY < midpoint;\n        \n        // Get order information\n        const fromIndex = Array.from(this.container.children).indexOf(this.draggedElement);\n        let toIndex = Array.from(this.container.children).indexOf(target);\n        \n        if (!insertBefore && toIndex < fromIndex) {\n            toIndex++;\n        } else if (insertBefore && toIndex > fromIndex) {\n            toIndex--;\n        }\n        \n        // Perform the reorder\n        if (fromIndex !== toIndex) {\n            // Move the element\n            if (insertBefore) {\n                target.parentNode.insertBefore(this.draggedElement, target);\n            } else {\n                target.parentNode.insertBefore(this.draggedElement, target.nextSibling);\n            }\n            \n            // Notify of reorder\n            this.onReorder({\n                element: this.draggedElement,\n                fromIndex,\n                toIndex,\n                fromId: this.draggedElement.dataset.id,\n                toId: target.dataset.id\n            });\n        }\n    }\n    \n    /**\n     * Find the actual drop target (draggable element)\n     */\n    findDropTarget(element) {\n        while (element && element !== this.container) {\n            if (element.matches(this.draggableSelector)) {\n                return element;\n            }\n            element = element.parentNode;\n        }\n        return null;\n    }\n    \n    /**\n     * Get current order of elements\n     */\n    getCurrentOrder() {\n        return Array.from(this.container.querySelectorAll(this.draggableSelector))\n            .map(el => ({\n                element: el,\n                id: el.dataset.id,\n                index: Array.from(this.container.children).indexOf(el)\n            }));\n    }\n    \n    /**\n     * Destroy drag and drop\n     */\n    destroy() {\n        if (this.container) {\n            this.container.removeEventListener('dragstart', this.handleDragStart);\n            this.container.removeEventListener('dragend', this.handleDragEnd);\n            this.container.removeEventListener('dragover', this.handleDragOver);\n            this.container.removeEventListener('drop', this.handleDrop);\n            this.container.removeEventListener('dragenter', this.handleDragEnter);\n            this.container.removeEventListener('dragleave', this.handleDragLeave);\n        }\n    }\n}\n\n/**\n * Touch-friendly drag and drop for mobile devices\n */\nexport class TouchDragAndDrop extends DragAndDrop {\n    constructor(options = {}) {\n        super(options);\n        \n        this.touchStartY = 0;\n        this.touchElement = null;\n        this.longPressTimer = null;\n        this.longPressDelay = options.longPressDelay || 500;\n    }\n    \n    /**\n     * Initialize touch drag and drop\n     */\n    init() {\n        super.init();\n        \n        this.container.addEventListener('touchstart', this.handleTouchStart.bind(this), { passive: false });\n        this.container.addEventListener('touchmove', this.handleTouchMove.bind(this), { passive: false });\n        this.container.addEventListener('touchend', this.handleTouchEnd.bind(this));\n    }\n    \n    /**\n     * Handle touch start\n     */\n    handleTouchStart(e) {\n        const target = this.findDropTarget(e.target);\n        if (!target) return;\n        \n        this.touchElement = target;\n        this.touchStartY = e.touches[0].clientY;\n        \n        // Start long press timer\n        this.longPressTimer = setTimeout(() => {\n            this.startTouchDrag(target);\n        }, this.longPressDelay);\n    }\n    \n    /**\n     * Handle touch move\n     */\n    handleTouchMove(e) {\n        if (this.longPressTimer) {\n            clearTimeout(this.longPressTimer);\n            this.longPressTimer = null;\n        }\n        \n        if (this.isDragging) {\n            e.preventDefault();\n            \n            const touch = e.touches[0];\n            const elementBelow = document.elementFromPoint(touch.clientX, touch.clientY);\n            const target = this.findDropTarget(elementBelow);\n            \n            if (target && target !== this.draggedElement) {\n                // Visual feedback for touch drag\n                this.container.querySelectorAll('.drag-over').forEach(el => {\n                    el.classList.remove('drag-over');\n                });\n                target.classList.add('drag-over');\n            }\n        }\n    }\n    \n    /**\n     * Handle touch end\n     */\n    handleTouchEnd(e) {\n        if (this.longPressTimer) {\n            clearTimeout(this.longPressTimer);\n            this.longPressTimer = null;\n        }\n        \n        if (this.isDragging) {\n            const touch = e.changedTouches[0];\n            const elementBelow = document.elementFromPoint(touch.clientX, touch.clientY);\n            const target = this.findDropTarget(elementBelow);\n            \n            if (target && target !== this.draggedElement) {\n                this.performTouchReorder(target, touch.clientY);\n            }\n            \n            this.endTouchDrag();\n        }\n        \n        this.touchElement = null;\n    }\n    \n    /**\n     * Start touch drag\n     */\n    startTouchDrag(element) {\n        this.draggedElement = element;\n        this.isDragging = true;\n        \n        element.classList.add('dragging');\n        element.style.opacity = '0.5';\n        \n        // Add haptic feedback if available\n        if (navigator.vibrate) {\n            navigator.vibrate(50);\n        }\n        \n        this.onDragStart(element);\n    }\n    \n    /**\n     * Perform touch reorder\n     */\n    performTouchReorder(target, clientY) {\n        const rect = target.getBoundingClientRect();\n        const midpoint = rect.top + rect.height / 2;\n        const insertBefore = clientY < midpoint;\n        \n        const fromIndex = Array.from(this.container.children).indexOf(this.draggedElement);\n        let toIndex = Array.from(this.container.children).indexOf(target);\n        \n        if (!insertBefore && toIndex < fromIndex) {\n            toIndex++;\n        } else if (insertBefore && toIndex > fromIndex) {\n            toIndex--;\n        }\n        \n        if (fromIndex !== toIndex) {\n            if (insertBefore) {\n                target.parentNode.insertBefore(this.draggedElement, target);\n            } else {\n                target.parentNode.insertBefore(this.draggedElement, target.nextSibling);\n            }\n            \n            this.onReorder({\n                element: this.draggedElement,\n                fromIndex,\n                toIndex,\n                fromId: this.draggedElement.dataset.id,\n                toId: target.dataset.id\n            });\n        }\n    }\n    \n    /**\n     * End touch drag\n     */\n    endTouchDrag() {\n        this.isDragging = false;\n        \n        if (this.draggedElement) {\n            this.draggedElement.classList.remove('dragging');\n            this.draggedElement.style.opacity = '';\n        }\n        \n        this.container.querySelectorAll('.drag-over').forEach(el => {\n            el.classList.remove('drag-over');\n        });\n        \n        this.onDragEnd(this.draggedElement);\n        \n        this.draggedElement = null;\n    }\n    \n    /**\n     * Destroy touch drag and drop\n     */\n    destroy() {\n        super.destroy();\n        \n        if (this.container) {\n            this.container.removeEventListener('touchstart', this.handleTouchStart);\n            this.container.removeEventListener('touchmove', this.handleTouchMove);\n            this.container.removeEventListener('touchend', this.handleTouchEnd);\n        }\n        \n        if (this.longPressTimer) {\n            clearTimeout(this.longPressTimer);\n        }\n    }\n}"